# Зачем и для кого
Для студентов и преподавателей при проверке 4 лабораторной работы.

## Фаззиг - что это?
Это когда набор данных для вашей программы генерируете не вы сами или преподаватели, а внешняя программка,
причем  соверашает несколько тысяч запусков в секунду с разными набороами данных. После каждой итерации набор данных мутируется так, чтобы открывать новые пути выполнения программы
Благодаря этому можно очень быстро и легко найти баг. 

## С чего начать?
Выполните команду
```
afl-clang-fast
```
Если нет ошибки и есть полноценный вывод, то переходите к разделу "Выполнение тестового примера"

Иначе - чиатем дальше.

### Если AFL++ не установлен (делаете на домашней системе), идем по ссылке на гайд
https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/INSTALL.md

И выполняем весь скрипт.

### Установка зависимостей 
```bash
sudo apt install lcov
```

## Немного информаци о проекте

В данном примере сделана мини 4 лабораторная работа.
В ней и будем искать ошибки с помощью фаззинг-тестирования.

Для начала выполните команду:

```bash
make help
```

Вы получите справку о том, как можно скомпилировать и выполнить программу:
``` bash
Available targets:
  all             : Build the main application                               //чистая сборка без санитайзеров 
  debug           : Build the application with AFL and ASAN for debugging    // Сборка с саниайтазерами и компилятором afl
  clean           : Remove object files                                  
  fuzz            : Run AFL fuzzing sessions                                 // Запуск фаззинг тестирования
  coverage_build  : Build the application with code coverage instrumentation // Сборка бинаря специально для получения покрытия кода
  coverage        : Generate code coverage report with gcc and lcov          // Сборка покрытия кода через gcov с генерацией html отчета
  coverage_clang  : Generate code coverage report with clang and llvm-cov    // Сборка покрытия кода через llvm-cov с генерацией html отчета
  
```

## Фаззинг
Выполним `make fuzz`. 
Запуск этой стадии выполнит следующее:
Сначала выполянются стадия `make debug` - файлы основной программы и библиотеки собираются с инструментацией санитайзеров
(санитайзером ASAN - это как валгринд, только красивее и "роняет" вашу программу сразу при обнаружении ошибки сигнал SIGABRT).

Далее для фаззера создается две папки **in** и **out** .

* В папке **in** нужно положить примеры данных, которые будут подаваться на вход программы (Здесь создаются самостоятельно).
* В **out** будет хранится наборы данных, которые обработал фаззер.
* Там же в папке **crashes** будут наборы данных, которые привели к падению. 
* Там же в папке **queue** хранятся наборы данных, которые открыли новые пути выполнения программы.
Их можно посмотреть через команду **cat**

Далее создаются 4 вкладки tmux'a, в каждой из которых выполняется команда:
```
afl-fuzz -i in/ -o out -x utf8.dict -- ./bin_asan
```

Флаги:
* `-i <dir>` указывавыем папку входных данны (корпус);
* `-o <dir>`  указывавыем папку с выходными данными;
* `-x <file>` путь до словаря (улучшает мутации входных данных).

Переключаться между вкладками tmux: ctrl+b (ОТПУСТИТЬ), n

Если будут краши - появятся красные цифры около надписи **SAVED CRASHES**, как здесь.

![AFL crush!](/docks/afl.jpg "AFL")


В этом тестовом проекте будет найдено пару крашей.

Посмотреть их можно в ` out/*/crashes/ `

## Сбор покрытия кода

Покрытие кода - метрика того, как хорошо тесты "покрыли" код.
Каждый набор данных идет по определенному пути выполения . Чем лучше тесты, тем большую часть кода они покроют.
Чтобы сработал valgrind или санитайзеры, необходимо "зацепить" некорректный участок кода. 
Собрав покрытие кода вы можете понять какие участки кода не выполнялись во время тестов и скорректировать набор данных так, чтобы программа выполнила иные участки кода.

Подробнее с примерами тут:
https://ps-group.github.io/cxx/coverage_gcc

### Как запустить в проекте?
После выполнения фаззинга, нужно выполнить:
`make coverage`

В консоли будет отображаться отладочная информация и через некоторе время вы увидете статистику по покрытию кода:

```bash
Overall coverage rate:
  lines......: 47.6% (10 of 21 lines)
  functions..: 33.3% (1 of 3 functions)
```
В корневой директории так же появится папка `report` с отчетом покрытия кода в формате html.

#### Покрытие можно собрать еще с помощью clang

Для этого выполнлить 
```
make coverage_clang
```

Будет примерно такой вывод в консоль:
```
Filename                      Regions    Missed Regions     Cover   Functions  Missed Functions  Executed       Lines      Missed Lines     Cover    Branches   Missed Branches     Cover
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
lib/string.c                        6                 0   100.00%           2                 0   100.00%          15                 0   100.00%           4                 0   100.00%
main.c                              5                 1    80.00%           1                 0   100.00%          11                 1    90.91%           2                 1    50.00%
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
TOTAL                              11                 1    90.91%           3                 0   100.00%          26                 1    96.15%           6                 1    83.33%
```

И в `coverage_clang_report` будет сохранен html отчет



#### Что произошло?

Сначала выполнилась стадия `make coverage_build`, в результате которой была выполнена специальная отдельная сборка бинаря для снятия покрытия кода.
После фаззинга у нас остались файлы в папкеке out.
В проекте есть скрипт `./get_cover` который подаст все данные из этой папки на вход программ.
Далее выполняется генерация статистики и отчета.



### Как выполнить самому?
Необходимо пересобрать программу с флагом '--coverage' (флаг компиляции и линковки).
После этого в проекте появятся файлы с расширением `*.gcno`.

После этого нужно запустить и подать наборы данных, например так:

```bash
./bin < test_string.txt
```
После этого в проекте появятся файлы с расширением `*.gcno`.

Посчитаем покрытие:

```bash
lcov -t "lab4" -o lab4.info -c -d .
```
В консоли будет отображаться отладочная информация и через некоторе время вы увидете статистику по покрытию кода:

```bash
Overall coverage rate:
  lines......: 47.6% (10 of 21 lines)
  functions..: 33.3% (1 of 3 functions)
```


Сгенерируем интерактивный html отчет:
```bash
genhtml -o report lab4.info
```

В корневой директории так же появится папка `report` с отчетом покрытия кода в формате html.

## Свой запуск
В данном репозитории сделан тестовый проект. 
Скорее всего ваша лаба по структуре файлов похожа на этот проект.
Поэтому можете использовать make файл от данного проекта.

Собственно в папке **lib** должен лежать файлик с расширеним `.c` - это реализация ваших внешних функций библиотеки **string**

И файлик `main` в корне - там ваша основнная программа c функцией maian.

Для запуска фаззинга выполнить:
```bash
make fuzz
```

Подождать минут 15.
Завершить все окна tmux с помощью `Ctrl+c`

Для сбора покрытия выполнить:
```bash
make coverage
```
